---
title: "R Notebook"
output: html_notebook
editor_options: 
  chunk_output_type: inline
---


# Инициализация пакетов

```{r}
library(tidyverse)
library(lubridate)
library(magrittr)
library(stringi)
library(stringr)
library(readxl)
library(iterators)
library(foreach)
library(doParallel)
library(zoo)

datafile <- "./data/2015.xlsx"
```

# Определение функции загрузки
```{r echo=FALSE}
get_month_data <- function(filename, sheetname="") {
  # хак по считыванию типов колонок
  raw <- read_excel(filename)
  ncol(raw)
  ctypes <- rep("text", 146)
  cnames <- str_c("grp_", seq_along(ctypes))
  raw <- read_excel(filename,
                   sheet=sheetname,
                   #col_names=cnames,
                   col_types=ctypes,
                   range = cell_cols("A:EP")) #, skip = 1)
  
  # имеем проблему, колонки с NA вместо имени
  # можно писать в одно преобразование, но специально разбил на шаги
  # трансформируем колонки
  df0 <- raw %>%
    repair_names(prefix="repaired_", sep="")
  
  # названия колонок размазаны по строкам 2-3. 2-ая -- группирующая, 3-я -- детализирующая
  # Надо их слить и переименовать колонки, причем приоритет имеет строка 3, как уточняющая
  #name_c2 <- tidyr::gather(df0[1, ], key = name, value = name_c2) # 1-ая колонка ушла в имена
  #name_c3 <- tidyr::gather(df0[2, ], key = name, value = name_c3) # 1-ая колонка ушла в имена
  
  # различные виды join не подойдут, поскольку мы хотим оставить все строки, вне зависимости от результата
  # сливать по именам опасно, вдруг есть дубли
  # names.df <- dplyr::full_join(name_c2, name_c3, by = "name")
  names_df <- tibble(name_c2=tidyr::gather(df0[1, ], key=name, value=v)$v,
                     name_c3=tidyr::gather(df0[2, ], key=name, value=v)$v) %>%
    # http://www.markhneedham.com/blog/2015/06/28/r-dplyr-update-rows-with-earlierprevious-rows-values/
    mutate(name_c2 = na.locf(name_c2)) %>%
    # если name_c3 = NA, то результат объединения строк также будет NA, нас это не очень устраивает
    mutate(name_fix = ifelse(is.na(name_c3), name_c2, str_c(name_c2, name_c3, sep=": "))) %>%
    mutate(name_fix = str_replace_all(name_fix, "\r", " ")) %>% # перевод строки
    mutate(name_fix = str_replace_all(name_fix, "\n", " ")) %>% # перевод строки
    mutate(name_fix = str_replace_all(name_fix, "  ", " "))
  
  df1 <- df0
  repl_df <- tribble(
    ~pattern, ~replacement,
    "Формующая часть: Угол напорного ящика", "angle_in",
    "Формующая часть: Разница скорости струи/сетки", "speed_diff_in",
    "Формующая часть: Открытие щели напорного ящика", "slot_in",
    "Формующая часть: Давление на напорном ящике", "pressure_in",
    "Поток: Концентрация при размоле", "concentration_in",
    "Производительность", "performance_out",
    "Вес м2", "weight_out",
    "Артикул", "mark_out"
  )
  names(df1) <- stri_replace_all_fixed(names_df$name_fix,
                                       pattern = repl_df$pattern,
                                       replacement = repl_df$replacement,
                                       vectorize_all = FALSE)
  
  
  # Все равно кривые имена, дубли
  names_df %>% 
    group_by(name_fix) %>% 
    filter(n()>1)
  
  df1 %<>% repair_names(prefix = "repaired_", sep = "")
  
  # выбираем только интересующие колонки
  df2 <- df1 %>% select(angle_in, speed_diff_in, slot_in, pressure_in, concentration_in,
                        performance_out, weight_out, mark_out) %>%
    filter(row_number() > 6) %>% # удаляем весь верхний шлак
    filter(complete.cases(.)) %>% # удаляем строки, содержащие пустые данные
    distinct() %>% # уберем идентичные строчки
    #http://stackoverflow.com/questions/27027347/mutate-each-summarise-each-in-dplyr-how-do-i-select-certain-columns-and-give
    mutate_at(vars(-mark_out), funs(as.numeric))
  
  df2
}

```



# Cоберем все закладки Excel файла вместе
```{r}
mnames <- c("Январь", "Февраль", "Март", "Апрель", "Май", "Июнь", 
            "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь")

tmp <- excel_sheets(datafile)
sheets <- tmp[tmp %in% mnames]

df <- foreach(it=iter(sheets), .combine=rbind, .packages='readxl') %do% {
  temp.df <- get_month_data(datafile, it) %>% mutate(month=it)

  temp.df
}

df
```

```{r}
# уникальные значения
unq <- map(df, unique)

unq
```

